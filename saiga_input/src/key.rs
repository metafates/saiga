use bitflags::bitflags;

pub struct KeyEvent {
    pub action: Action,

    /// "key" is the logical key that was pressed. For example, if
    /// a Dvorak keyboard layout is being used on a US keyboard,
    /// the "i" physical key will be reported as "c". The physical
    /// key is the key that was physically pressed on the keyboard.
    pub key: Key,
    pub physical_key: Key,

    /// Mods are the modifiers that are pressed.
    pub mods: Mods,

    /// Composing is true when this key event is part of a dead key
    /// composition sequence and we're in the middle of it.
    pub composing: bool,

    /// The mods that were consumed in order to generate the text
    /// in utf8. This has the mods set that were consumed, so to
    /// get the set of mods that are effective you must negate
    /// mods with this.
    ///
    /// This field is meaningless if utf8 is empty.
    pub consumed_mods: Mods,

    /// The utf8 sequence that was generated by this key event.
    /// This will be an empty string if there is no text generated.
    /// If composing is true and this is non-empty, this is preedit
    /// text.
    pub utf8: String,
}

impl Default for KeyEvent {
    fn default() -> Self {
        Self {
            action: Action::Press,
            key: Key::Invalid,
            physical_key: Key::Invalid,
            mods: Mods::empty(),
            composing: false,
            consumed_mods: Mods::empty(),
            utf8: String::new(),
        }
    }
}

impl KeyEvent {
    pub fn effective_mods(&self) -> Mods {
        if self.utf8.is_empty() {
            self.mods
        } else {
            self.mods - self.consumed_mods
        }
    }
}

bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    pub struct Mods: u8 {
        const SHIFT = 0b0001;
        const CTRL  = 0b0010;
        const ALT   = 0b0100;
        const META  = 0b1000;
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Action {
    Release,
    Press,
    Repeat,
}

pub enum Key {
    Invalid,
    // a-z
    A,
    B,
    C,
    D,
    E,
    F,
    G,
    H,
    I,
    J,
    K,
    L,
    M,
    N,
    O,
    P,
    Q,
    R,
    S,
    T,
    U,
    V,
    W,
    X,
    Y,
    Z,

    // numbers
    Zero,
    One,
    Two,
    Three,
    Four,
    Five,
    Six,
    Seven,
    Eight,
    Nine,

    // punctuation
    Semicolon,
    Space,
    Apostrophe,
    Comma,
    GraveAccent, // `
    Period,
    Slash,
    Minus,
    Plus,
    Equal,
    LeftBracket,  // [
    RightBracket, // ]
    Backslash,    // \

    // control
    Up,
    Down,
    Right,
    Left,
    Home,
    End,
    Insert,
    Delete,
    CapsLock,
    ScrollLock,
    NumLock,
    PageUp,
    PageDown,
    Escape,
    Enter,
    Tab,
    Backspace,
    PrintScreen,
    Pause,

    // function keys
    F1,
    F2,
    F3,
    F4,
    F5,
    F6,
    F7,
    F8,
    F9,
    F10,
    F11,
    F12,
    F13,
    F14,
    F15,
    F16,
    F17,
    F18,
    F19,
    F20,
    F21,
    F22,
    F23,
    F24,
    F25,

    // keypad
    Kp0,
    Kp1,
    Kp2,
    Kp3,
    Kp4,
    Kp5,
    Kp6,
    Kp7,
    Kp8,
    Kp9,
    KpDecimal,
    KpDivide,
    KpMultiply,
    KpSubtract,
    KpAdd,
    KpEnter,
    KpEqual,
    KpSeparator,
    KpLeft,
    KpRight,
    KpUp,
    KpDown,
    KpPageUp,
    KpPageDown,
    KpHome,
    KpEnd,
    KpInsert,
    KpDelete,
    KpBegin,

    // TODO: media keys

    // modifiers
    LeftShift,
    LeftControl,
    LeftAlt,
    LeftSuper,
    RightShift,
    RightControl,
    RightAlt,
    RightSuper,
}
